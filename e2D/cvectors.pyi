"""
Type stubs for cvectors module (Cython-compiled Vector2D and Vector2Int)
Provides type hints for all vector operations
"""

from typing import List, Tuple, Union, Iterator
from .types import Number
import numpy as np
import numpy.typing as npt

class Vector2Int:
    """
    High-performance 2D integer vector class for grid systems and precise calculations.
    
    Perfect for:
    - Grid coordinates (tilemaps, cells)
    - Array indexing (no float precision errors)
    - Discrete math operations
    - Pathfinding (A*, BFS, DFS)
    
    Uses Cython with numpy int32 backend for maximum performance and precision.
    """
    
    data: npt.NDArray[np.int32]
    
    def __init__(self, x: int = 0, y: int = 0) -> None:
        """Initialize vector with x, y integer components"""
        ...
    
    # Property accessors
    @property
    def x(self) -> int:
        """X component"""
        ...
    
    @x.setter
    def x(self, value: int) -> None: ...
    
    @property
    def y(self) -> int:
        """Y component"""
        ...
    
    @y.setter
    def y(self, value: int) -> None: ...
    
    @property
    def length(self) -> float:
        """Vector length (magnitude) - returns float"""
        ...
    
    @property
    def length_sqrd(self) -> int:
        """Squared length (faster, avoids sqrt)"""
        ...
    
    # Methods
    def copy(self) -> Vector2Int:
        """Fast copy"""
        ...
    
    def set(self, x: int, y: int) -> None:
        """Set both components"""
        ...
    
    def iadd(self, other: Vector2Int) -> None:
        """In-place addition"""
        ...
    
    def isub(self, other: Vector2Int) -> None:
        """In-place subtraction"""
        ...
    
    def imul(self, scalar: int) -> None:
        """In-place scalar multiplication"""
        ...
    
    def ifloordiv(self, scalar: int) -> None:
        """In-place integer floor division"""
        ...
    
    def imod(self, scalar: int) -> None:
        """In-place modulo operation"""
        ...
    
    def imul_vec(self, other: Vector2Int) -> None:
        """In-place component-wise multiplication"""
        ...
    
    def iadd_scalar(self, scalar: int) -> None:
        """In-place scalar addition"""
        ...
    
    def isub_scalar(self, scalar: int) -> None:
        """In-place scalar subtraction"""
        ...
    
    def iabs(self) -> None:
        """Take absolute value in-place"""
        ...
    
    def clamp_inplace(self, min_val: Vector2Int, max_val: Vector2Int) -> None:
        """Clamp components in-place"""
        ...
    
    def add(self, other: Vector2Int) -> Vector2Int:
        """Addition (returns new vector)"""
        ...
    
    def sub(self, other: Vector2Int) -> Vector2Int:
        """Subtraction (returns new vector)"""
        ...
    
    def mul(self, scalar: int) -> Vector2Int:
        """Scalar multiplication (returns new vector)"""
        ...
    
    def floordiv(self, scalar: int) -> Vector2Int:
        """Floor division (returns new vector)"""
        ...
    
    def mod(self, scalar: int) -> Vector2Int:
        """Modulo operation (returns new vector)"""
        ...
    
    def mul_vec(self, other: Vector2Int) -> Vector2Int:
        """Component-wise multiplication (returns new vector)"""
        ...
    
    def abs_vec(self) -> Vector2Int:
        """Absolute value (returns new vector)"""
        ...
    
    def dot_product(self, other: Vector2Int) -> int:
        """Dot product"""
        ...
    
    def distance_squared(self, other: Vector2Int) -> int:
        """Squared distance to another vector (avoids sqrt)"""
        ...
    
    def distance_to(self, other: Vector2Int) -> float:
        """Distance to another vector (float result)"""
        ...
    
    def manhattan_distance(self, other: Vector2Int) -> int:
        """Manhattan distance (grid distance)"""
        ...
    
    def chebyshev_distance(self, other: Vector2Int) -> int:
        """Chebyshev distance (max of abs differences)"""
        ...
    
    def clamp(self, min_val: Vector2Int, max_val: Vector2Int) -> Vector2Int:
        """Clamp (returns new)"""
        ...
    
    def to_float(self) -> Vector2D:
        """Convert to Vector2D (float)"""
        ...
    
    def to_tuple(self) -> Tuple[int, int]:
        """Convert to Python tuple"""
        ...
    
    def to_list(self) -> List[int]:
        """Convert to Python list"""
        ...
    
    # Operators
    def __add__(self, other: Union[Vector2Int, int]) -> Vector2Int: ...
    def __sub__(self, other: Union[Vector2Int, int]) -> Vector2Int: ...
    def __mul__(self, other: Union[Vector2Int, int]) -> Vector2Int: ...
    def __floordiv__(self, other: Union[Vector2Int, int]) -> Vector2Int: ...
    def __mod__(self, other: Union[Vector2Int, int]) -> Vector2Int: ...
    def __iadd__(self, other: Union[Vector2Int, int]) -> Vector2Int: ...
    def __isub__(self, other: Union[Vector2Int, int]) -> Vector2Int: ...
    def __imul__(self, other: Union[Vector2Int, int]) -> Vector2Int: ...
    def __ifloordiv__(self, other: int) -> Vector2Int: ...
    def __imod__(self, other: int) -> Vector2Int: ...
    def __radd__(self, other: int) -> Vector2Int: ...
    def __rsub__(self, other: int) -> Vector2Int: ...
    def __rmul__(self, other: int) -> Vector2Int: ...
    def __rfloordiv__(self, other: int) -> Vector2Int: ...
    def __neg__(self) -> Vector2Int: ...
    def __abs__(self) -> Vector2Int: ...
    def __pos__(self) -> Vector2Int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: Vector2Int) -> bool: ...
    def __le__(self, other: Vector2Int) -> bool: ...
    def __gt__(self, other: Vector2Int) -> bool: ...
    def __ge__(self, other: Vector2Int) -> bool: ...
    def __call__(self) -> Tuple[int, int]: ...
    def __getitem__(self, idx: int) -> int: ...
    def __setitem__(self, idx: int, value: int) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    
    # Static methods
    @staticmethod
    def zero() -> Vector2Int:
        """Create zero vector (0, 0)"""
        ...
    
    @staticmethod
    def one() -> Vector2Int:
        """Create one vector (1, 1)"""
        ...
    
    @staticmethod
    def up() -> Vector2Int:
        """Create up vector (0, 1)"""
        ...
    
    @staticmethod
    def down() -> Vector2Int:
        """Create down vector (0, -1)"""
        ...
    
    @staticmethod
    def left() -> Vector2Int:
        """Create left vector (-1, 0)"""
        ...
    
    @staticmethod
    def right() -> Vector2Int:
        """Create right vector (1, 0)"""
        ...
    
    @staticmethod
    def random(min_val: int = 0, max_val: int = 1) -> Vector2Int:
        """Create random integer vector"""
        ...

class Vector2D:
    """
    High-performance 2D vector class optimized for heavy simulations.
    
    Uses contiguous numpy arrays and Cython for near-C performance.
    All operations are optimized with no bounds checking and inline C math.
    """
    
    data: npt.NDArray[np.float64]
    
    def __init__(self, x: float = 0.0, y: float = 0.0) -> None:
        """Initialize vector with x, y components"""
        ...
    
    # Property accessors
    @property
    def x(self) -> float:
        """X component"""
        ...
    
    @x.setter
    def x(self, value: float) -> None: ...
    
    @property
    def y(self) -> float:
        """Y component"""
        ...
    
    @y.setter
    def y(self, value: float) -> None: ...
    
    @property
    def length(self) -> float:
        """Vector length (magnitude)"""
        ...
    
    @property
    def length_sqrd(self) -> float:
        """Squared length (faster, avoids sqrt)"""
        ...
    
    @property
    def angle(self) -> float:
        """Angle of this vector"""
        ...
    
    @angle.setter
    def angle(self, new_angle: float) -> None:
        """Set angle while maintaining magnitude"""
        ...
    
    # Methods
    def copy(self) -> Vector2D:
        """Fast copy"""
        ...
    
    def set(self, x: float, y: float) -> None:
        """Set both components"""
        ...
    
    def iadd(self, other: Vector2D) -> None:
        """In-place addition"""
        ...
    
    def isub(self, other: Vector2D) -> None:
        """In-place subtraction"""
        ...
    
    def imul(self, scalar: float) -> None:
        """In-place scalar multiplication"""
        ...
    
    def idiv(self, scalar: float) -> None:
        """In-place division"""
        ...
    
    def imul_vec(self, other: Vector2D) -> None:
        """In-place component-wise multiplication"""
        ...
    
    def iadd_scalar(self, scalar: float) -> None:
        """In-place scalar addition"""
        ...
    
    def isub_scalar(self, scalar: float) -> None:
        """In-place scalar subtraction"""
        ...
    
    def normalize(self) -> None:
        """Normalize in-place"""
        ...
    
    def clamp_inplace(self, min_val: Vector2D, max_val: Vector2D) -> None:
        """Clamp components in-place"""
        ...
    
    def add(self, other: Vector2D) -> Vector2D:
        """Addition (returns new vector)"""
        ...
    
    def sub(self, other: Vector2D) -> Vector2D:
        """Subtraction (returns new vector)"""
        ...
    
    def mul(self, scalar: float) -> Vector2D:
        """Scalar multiplication (returns new vector)"""
        ...
    
    def mul_vec(self, other: Vector2D) -> Vector2D:
        """Component-wise multiplication (returns new vector)"""
        ...
    
    def normalized(self) -> Vector2D:
        """Get normalized vector (returns new)"""
        ...
    
    def dot_product(self, other: Vector2D) -> float:
        """Dot product"""
        ...
    
    def distance_to(self, other: Vector2D, rooted: bool = True) -> float:
        """Distance to another vector"""
        ...
    
    def angle_to(self, other: Vector2D) -> float:
        """Angle to another vector"""
        ...
    
    def rotate(self, angle: float) -> Vector2D:
        """Rotate vector by angle (returns new)"""
        ...
    
    def irotate(self, angle: float) -> None:
        """Rotate in-place"""
        ...
    
    def lerp(self, other: Vector2D, t: float) -> Vector2D:
        """Linear interpolation"""
        ...
    
    def clamp(self, min_val: Vector2D, max_val: Vector2D) -> Vector2D:
        """Clamp (returns new)"""
        ...
    
    def projection(self, other: Vector2D) -> Vector2D:
        """Project this vector onto another"""
        ...
    
    def reflection(self, normal: Vector2D) -> Vector2D:
        """Reflect vector across normal"""
        ...
    
    # Python operator overloads
    def __add__(self, other: Vector2D | Number) -> Vector2D: ...
    def __sub__(self, other: Vector2D | Number) -> Vector2D: ...
    def __mul__(self, other: Vector2D | Number) -> Vector2D: ...
    def __truediv__(self, other: Number | Vector2D) -> Vector2D: ...
    def __iadd__(self, other: Vector2D | Number) -> Vector2D: ...
    def __isub__(self, other: Vector2D | Number) -> Vector2D: ...
    def __imul__(self, other: Vector2D | Number) -> Vector2D: ...
    def __itruediv__(self, other: Number) -> Vector2D: ...
    def __radd__(self, other: Number) -> Vector2D: ...
    def __rsub__(self, other: Number) -> Vector2D: ...
    def __rmul__(self, other: Number) -> Vector2D: ...
    def __rtruediv__(self, other: Number) -> Vector2D: ...
    def __neg__(self) -> Vector2D: ...
    def __abs__(self) -> Vector2D: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: Vector2D) -> bool: ...
    def __le__(self, other: Vector2D) -> bool: ...
    def __gt__(self, other: Vector2D) -> bool: ...
    def __ge__(self, other: Vector2D) -> bool: ...
    def __call__(self) -> Tuple[float, float]: ...
    def __getitem__(self, idx: int) -> float: ...
    def __setitem__(self, idx: int, value: float) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[float]: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    
    # Utility methods
    def to_list(self) -> List[float]:
        """Convert to Python list"""
        ...
    
    def to_tuple(self) -> Tuple[float, float]:
        """Convert to Python tuple"""
        ...
    
    def to_int(self) -> Vector2Int:
        """Convert to Vector2Int (truncates to integer)"""
        ...
    
    # Class methods for common vectors
    @staticmethod
    def zero() -> Vector2D:
        """Create zero vector (0, 0)"""
        ...
    
    @staticmethod
    def one() -> Vector2D:
        """Create one vector (1, 1)"""
        ...
    
    @staticmethod
    def up() -> Vector2D:
        """Create up vector (0, 1)"""
        ...
    
    @staticmethod
    def down() -> Vector2D:
        """Create down vector (0, -1)"""
        ...
    
    @staticmethod
    def left() -> Vector2D:
        """Create left vector (-1, 0)"""
        ...
    
    @staticmethod
    def right() -> Vector2D:
        """Create right vector (1, 0)"""
        ...
    
    @staticmethod
    def random(min_val: float = 0.0, max_val: float = 1.0) -> Vector2D:
        """Create random vector"""
        ...

# Batch operations for processing many vectors at once
def batch_add_inplace(vectors: List[Vector2D], displacement: Vector2D) -> None:
    """Add displacement to all vectors in-place (ultra-fast)"""
    ...

def batch_scale_inplace(vectors: List[Vector2D], scalar: float) -> None:
    """Scale all vectors in-place"""
    ...

def batch_normalize_inplace(vectors: List[Vector2D]) -> None:
    """Normalize all vectors in-place"""
    ...

def vectors_to_array(vectors: List[Vector2D]) -> npt.NDArray[np.float64]:
    """Convert list of vectors to numpy array (fast)"""
    ...

def array_to_vectors(arr: npt.NDArray[np.float64]) -> List[Vector2D]:
    """Convert numpy array to list of vectors (fast)"""
    ...
